# Generated by `rjournal_pdf_article()` using `knitr::purl()`: do not edit by hand
# Please edit vivid.Rmd to modify this file

## ----setup, include=FALSE-----------------------------------------------------
library(knitr)
knitr::opts_chunk$set(
  fig.align = "center",
  fig.retina=5,
  echo = FALSE,
  warning = FALSE,
  message = FALSE,
  cache = TRUE,
  cache.extra = rand_seed
)


library("vivid") # for visualisations
library("randomForest") # to create model
library('xgboost') # to create model
library("ggplot2") # for visualisations
library('MASS') # for data


## ----rf, echo=TRUE------------------------------------------------------------
library("randomForest") 
library("MASS")
set.seed(1701)  
data("Boston")

rf <- randomForest(medv ~., 
                   data = Boston, 
                   importance = TRUE)


## ----xgboost, echo=TRUE-------------------------------------------------------
library("xgboost") 
gbst <- xgboost(data = as.matrix(Boston[,1:13]), 
                label =  as.matrix(Boston[,14]),
                nrounds = 100,
                verbose = 0)


## ---- vivirf, echo=TRUE, eval=FALSE-------------------------------------------
#> library("vivid")
#> 
#> set.seed(1701)
#> viviRf <- vivi(fit = rf,
#>                data = Boston,
#>                response = "medv",
#>                reorder = FALSE,
#>                normalized = FALSE,
#>                importanceType = 'agnostic',
#>                gridSize = 50,
#>                nmax = 500,
#>                class = 1,
#>                predictFun = NULL)


## ----echo=FALSE, eval=TRUE----------------------------------------------------
load("vivi.Rdata")


## ---- echo=TRUE---------------------------------------------------------------
# predict function for GBM
pFun <- function(fit, data, ...) predict(fit, as.matrix(data[,1:13]))


## ---- vivigbm, echo=TRUE, eval=FALSE------------------------------------------
#> set.seed(1701)
#> viviGBst <- vivi(fit = gbst,
#>                  data = Boston,
#>                  response = "medv",
#>                  reorder = FALSE,
#>                  normalized = FALSE,
#>                  predictFun = pFun)


## ----  speedtest, echo=FALSE,   out.width = '60%', fig.cap = "Mean time over five runs, on two MacBooks, for the creation of a vivid matrix for different models. Times are highly dependent on the model fit, with NN the fastest and random forests the slowest."----
knitr::include_graphics("speedTestsplot.png")


## ----vip,  echo=TRUE, eval=FALSE----------------------------------------------
#> library("vip")
#> # get model specific VImps using vip package
#> vipVImp <- vi(rf, method = 'model')
#> # get VInts using vip package
#> vipVInt <- vint(rf, feature_names = names(Boston[-14]))
#> 
#> # turn into vivi-matrix
#> vipViviMat <- vip2vivid(importance = vipVImp, interaction = vipVInt)


## ---- avgMatrix, echo=TRUE----------------------------------------------------
# average over matrices and seriate to get common ordering
viviAvg <- (viviRf + viviGBst) / 2
viviAvgReorder <- vividReorder(viviAvg)

# reorder vivi-matrices 
ord <- colnames(viviAvgReorder)
viviRf <- viviRf[ord,ord]
viviGBst <- viviGBst[ord,ord]


## ---- heatmaps,  echo=TRUE,fig.subcap = c("", ""), out.width="50%", fig.cap = "Agnostic variable importance and variable interaction scores for a random forest fit in (a) and GBM fit in (b) on the Boston housing data displayed as a heatmap. The random forest fit has weaker interactions and lower importance scores than the GBM fit. Both fits identify $lstat$ as the most important followed by $rm$. In both fits, $lstat$ has numerous interactions with other variables, notably $crim$ in the random forest fit and $nox$ in the GBM fit."----
viviHeatmap(viviRf, angle = 45, intLims = c(0,1), impLims = c(0,8))
viviHeatmap(viviGBst, angle = 45, intLims = c(0,1), impLims = c(0,8))



## ---- networks1, echo = TRUE, fig.subcap = c("", ""), out.width="50%", fig.cap = "Network plots showing VIVI scores obtained from a GBM fit on the Boston housing data. In (a) we display the all values in a circle. In (b) we use a hierarchical clustering to group variable with high VIVI together and rearrange the layout using an igraph function."----

# default network plot for GBM
viviNetwork(viviGBst)

# clustered and filtered network for GBM
intVals <- viviGBst
diag(intVals) <- NA 

# select VIVI values in top 10%
impTresh <- quantile(diag(viviGBst),.9)
intThresh <- quantile(intVals,.9,na.rm=TRUE)
sv <- which(diag(viviGBst) > impTresh |
              apply(intVals, 1, max, na.rm=TRUE) > intThresh)
              
h <- hclust(-as.dist(viviGBst[sv,sv]), method="single")

viviNetwork(viviGBst[sv,sv],
            intLims = c(0,1),
            impLims = c(0,8),
            cluster = cutree(h, k = 3), # specify number of groups
            layout = igraph::layout_as_star)



## ---- dataframe, echo=TRUE----------------------------------------------------
class(viviRf)<- c("vivid", class(viviRf)) 
head(as.data.frame(viviRf), 4)


## ---- pdpRf,echo = TRUE,  out.width="100%", fig.width=10, fig.height=3,fig.cap = "Partial dependence plots (black line) with individual conditional expectation curves (colored lines) of a GBM fit on the Boston housing data. The changing partial dependence and ICE curves of $lstat$ and $rm$ indicate that these variables have some impact on the response."----
top5 <- colnames(viviGBst)[1:5]
pdpVars(data = Boston,
        fit = gbst,
        response = 'medv',
        vars = top5,
        predictFun = pFun)


## ---- gpdp, echo = TRUE, out.width="75%", fig.width=5, fig.height=4, fig.align='center', fig.cap = "Filtered generalized pairs partial dependence plot for a GBM fit on the Boston housing data. From both the univariate and bivariate PDPs, we can see that $lstat$ and $rm$ have an impact on the response. As $lstat$ decreases and $rm$ increases, predicted median house price value goes up. The bivariate PDP of $lstat:nox$ shows that as $nox$ increases, the predicted value decreases."----


set.seed(1701)
pdpPairs(data = Boston,
         fit = gbst,
         response = "medv",
         gridSize = 20,
         nIce = 50,
         vars = top5,
         convexHull = TRUE,
         fitlims = "pdp",
         predictFun = pFun)


## ---- zpdpGbm1, echo = TRUE, out.width="50%", fig.width=3, fig.height=2, fig.align='center', fig.cap = "Zen partial dependence plot for the GBM fit on the Boston data. Here we display first five variables from the GBM's `vivid` matrix. Only plots for consecutive variables are shown."----

pdpZen(data = Boston,
       fit = gbst,
       response = "medv",
       convexHull = TRUE,
       zpath = top5,
       predictFun = pFun)


## ---- echo=TRUE---------------------------------------------------------------
intThresh <- quantile(intVals,.9,na.rm=TRUE)
# set zpaths with different parameters
zpGw  <- zPath(viv = viviGBst, cutoff = intThresh, method = 'greedy.weighted')
zpGw
zpSw  <- zPath(viv = viviGBst, cutoff = intThresh, connect = FALSE, method = 'strictly.weighted')
zpSw


## ---- zpdpGBM, echo = TRUE, fig.subcap = c("", ""), out.width="50%", fig.height = 5, fig.width = 3, fig.cap = "ZPDP for a GBM fit on the Boston data. In (a) the zpath is defined by the `greedy.weighted` sorting method. In (b), the sorting method is defined by the `strictly.weighted` method and is unconnected. For low values of $lstat$ and and high values of $rm$, predicted median house price value increases."----

pdpZen(data = Boston,
       fit = gbst,
       response = "medv",
       zpath = zpGw,
       convexHull = TRUE,
       predictFun = pFun) 

pdpZen(data = Boston,
       fit = gbst,
       response = "medv",
       zpath = zpSw,
       convexHull = TRUE,
       predictFun = pFun)


